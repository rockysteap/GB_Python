def countdown(n):
    result = []
    while n != 0:
        result.append(n - 1)
        n -= 1
    return result


# Функция выше генерирует убывающую последовательность.
# При работе использует промежуточный список result
print(countdown(4))
# При каждом обращении генерирует последовательность заново
print(countdown(4))


# В данном случае есть возможность использовать генератор

def gen_countdown(n):
    while n != 0:
        yield n - 1
        n -= 1


# В отличие от функции, функция-генератор не создает последовательность сразу.
# Генератор необходимо присвоить переменной, так как в общем виде
# print(gen_countdown(4)) генератор возвращает <generator object>
g = gen_countdown(4)
# Присвоив генератор переменной, мы ещё не производим его запуск итераций.
# Запускаются итерации генератора с помощью функции next(), при этом генерируется
# всего лишь одно следующее значение последовательности, которое и возвращается
# при вызове next() с помощью оператора yield, прописанного в функции
# yield это некий return, как в обычной функции, только отдающий порционно - раз за итерацию
print(next(g))
#  затем следующее значение
print(next(g))
# затем следующее, и так далее
print(next(g))
print(next(g))
# После окончания последовательности при новом вызове на новую итерацию
# print(next(g))
# генератор вернет ошибку: # StopIteration

# Поэтому безопаснее обращаться к генератору с помощью цикла, например:
for i in gen_countdown(4):
    print(i)

# Так как генератор возвращает данные итерационно, к генератору нельзя обратится
# по индексу
